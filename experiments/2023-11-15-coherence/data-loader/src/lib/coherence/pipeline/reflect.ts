const decorators = {
  goals: (concept: string, query: string) => `Can ${concept} achieve "${query}"?`,
  problems: (concept: string, query: string) => `Can ${concept} solve "${query}"?`,
  supporters: (concept: string, query: string) => `Will ${query} benefit from ${concept}?`,
  protesters: (concept: string, query: string) => `Will ${query} dislike ${concept}?`,
  guidanceDo: (concept: string, query: string) => `Is "${query}" a best practice for ${concept}?`,
  guidanceDont: (concept: string, query: string) => `Is "${query}" a best practice for ${concept}?`,
  conceptAlternativeNames: (concept: string, query: string) => `What do we know about the concept similar to ${concept}, called "${query}"?`,
  questionedConcepts: (concept: string, query: string) => `${concept} raises a question about "${query}", what is the answer?`,
  "": (_concept: string, query: string) => query,
};

const assumptions = {
  goals: (concept: string, query: string) => `${concept} might help achieve ${query}`,
  problems: (concept: string, query: string) => `${concept} might solve ${query}`,
  supporters: (concept: string, query: string) => `${concept} might benefit ${query}`,
  protesters: (concept: string, query: string) => `${concept} might not benefit ${query}`,
  guidanceDo: (concept: string, query: string) => `"${query}" might be a best practice for ${concept}`,
  guidanceDont: (concept: string, query: string) => `"${query}" might be a best practice for ${concept}`,
  conceptAlternativeNames: (concept: string, query: string) => `${concept} might be known as ${query}`,
  questionedConcepts: (concept: string, query: string) => `${concept} might raise the question ${query}`,
  "": (_concept: string, query: string) => `None`,
};

function getDecoratorName(progressObject: any, query: string): keyof typeof decorators {
  if (progressObject.goals.includes(query)) {
    return "goals";
  } else if (progressObject.problems?.includes(query)) {
    return "problems";
  } else if (progressObject.supporters?.includes(query)) {
    return "supporters";
  } else if (progressObject.protesters?.includes(query)) {
    return "protesters";
  } else if (progressObject.guidance?.dos?.includes(query)) {
    return "guidanceDo";
  } else if (progressObject.guidance?.donts?.includes(query)) {
    return "guidanceDont";
  } else if (progressObject.concept.alternativeNames?.includes(query)) {
    return "conceptAlternativeNames";
  } else if (progressObject.questionedConcepts?.includes(query)) {
    return "questionedConcepts";
  }

  return "";
}

export function getImpliedQuestion(progressObject: any, concept: string, query: string) {
  const decoratorName = getDecoratorName(progressObject, query);
  return decorators[decoratorName](concept, query);
}

export function getAssumption(progressObject: any, concept: string, query: string) {
  const decoratorName = getDecoratorName(progressObject, query);
  return assumptions[decoratorName](concept, query);
}

/**
 * # Reflect v2 format
 *
 * Goals/Problem/Supporter/Protester/GuidanceDo/GuidanceDont
 * Assumption: ${concept} might help achieve ${query}
 * Finding: ${evidence}
 *
 * # Alt names
 *
 * Assumption: this finding might apply to ${concept}
 * Query: ${query}
 * Finding: ${evidence}
 *
 * # Questioned concept
 *
 * Assumptions: the question might help people work with ${concept}
 * Question: ${query}
 * Finding: ${evidence}
 */

/**
 * # Refect v3
 *
 * Assumption: ...
 * Query: ...
 * Finding: ...
 * Context: <This will be generated by GPT, asking how the finding is related to the concept>
 */
